// The function name
#pragma kernel Density
#include "/Includes/Noise.compute"
#include "/Includes/Density.compute"

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise3D.hlsl"

// Noise settings
StructuredBuffer<float3> offsets;
RWStructuredBuffer<float> manualData;
RWStructuredBuffer<int> pointsStatus;

int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float heightGredient;
float multiFractalWeight;
bool closeEdges;
bool b1;
bool b2;
float f1;
float f2;
float f3;
float4 params;
float isoLevel;


[numthreads(numThreads,numThreads,numThreads)]
void Density (int3 id : SV_DispatchThreadID)
{
    int index = indexFromCoord(id.x,id.y,id.z);
    
    // Out of bound
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }
    
    // World pos
    float3 pos3D = centre + id * spacing - boundsSize/2;
    float3 pos = 0;
    pos = pos3D;
    // pos.xz = pos3D.xz;

    float offsetNoise = 0;
    
    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j = 0; j < octaves; j++) {
        // 0-1
        float n = snoise((pos+offsetNoise) * frequency + offsets[j]);

        if(j >= 1){
            n *= noise * multiFractalWeight;
        }
        
        n = abs(f2 * n - f3);
        n = f1 - n;
        // n = n * 1.5 - 1.0;
        if(b1)
        {
            n = clamp(n, 0, 1);

        }
        
        // n = abs(2 * n - 1);
        
        noise += n * amplitude;

        amplitude *= persistence;
        frequency *= lacunarity;
    }

    // noise = abs(2 * noise - 1);  

    // The higher the position is, the less likely it is gonna appear.
    float finalVal = -pos.y * heightGredient + floorOffset + noise * noiseWeight;

    if (closeEdges) {
        float3 edgeOffset = abs(pos*2)-worldSize + spacing/2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x,edgeOffset.y),edgeOffset.z)));
        finalVal = finalVal * (1-edgeWeight) - 100 * edgeWeight;
        
    }

    finalVal = clamp(finalVal, isoLevel - 10, isoLevel + 10);
    
    if(finalVal + manualData[index] - isoLevel > 0)
    pointsStatus[0] = 1;
    if(finalVal + manualData[index] - isoLevel < 0)
    pointsStatus[1] = 1;
    // This index list can be used in marchingcubes.compute
    points[index] = float4(pos, finalVal + manualData[index]);
}
