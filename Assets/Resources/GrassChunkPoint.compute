#include "Assets/Scripts/Compute/Includes/Noise.compute"
#include "Assets/Resources/Random.cginc"


struct GrassData {
    float4 position;
    bool enable;
};

struct GroundLevelData
{
    float weight;
    float twoDimentionalHeight;
    bool hasMeshAtThisPlace;
};

RWStructuredBuffer<GrassData> _GrassDataBuffer;
RWStructuredBuffer<GroundLevelData> GroundLevelDataBuffer;

int _Dimension, numGrassesPerAxis, numPointsPerAxis;
float chunkBoundSize;
float3 centre;
float grassSpacing;
float meshSpacing;
float4 requiredColor;

float ratio;
float worldPosOffset;
float textureSize;

float _DisplacementStrength;
RWTexture3D<float4> universalRenderTex;

int indexFromCoord(uint x, uint y, uint z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}

// return: 0 - false, 1 - true
int colorCmp(float4 col1, float4 col2){
    float threhold = 0.01f;
    return 1 - step(threhold, distance(col1.rgb, col2.rgb));
}

// k0: Calculate vertical position of every 2d mesh point from GroundLevelData buffer
#pragma kernel CalculateGrassPos

[numthreads(8,8,8)]
void CalculateGrassPos(int3 id : SV_DispatchThreadID) {
    if(id.y <= 0){
        return;
    }

    int index = indexFromCoord(id.x, id.y, id.z);
    int below_index = indexFromCoord(id.x, id.y - 1, id.z);

    if(GroundLevelDataBuffer[index].weight < 0 && GroundLevelDataBuffer[below_index].weight > 0){
        float weight1 = -GroundLevelDataBuffer[index].weight;
        float weight2 =  GroundLevelDataBuffer[below_index].weight;
        float weightSum = weight1 + weight2;

        float posY1 = centre.y + id.y * meshSpacing - chunkBoundSize / 2;
        float posY2 = centre.y + (id.y - 1) * meshSpacing - chunkBoundSize / 2;
        float posY = posY1 * (weight2 / weightSum) + posY2 * (weight1 / weightSum);

        GroundLevelDataBuffer[id.x + id.z * numPointsPerAxis].twoDimentionalHeight = posY;
    }
}

// k1: Calculate exact position of every grass from GroundLevelData (By interpolation)
#pragma kernel InitializeGrassChunk

[numthreads(8,8,1)]
void InitializeGrassChunk(uint2 id : SV_DispatchThreadID) {
    if (id.x >= numGrassesPerAxis || id.y >= numGrassesPerAxis) {
        return;
    }
    
    GrassData grass;
    
    float3 id223 = float3(id.x, 0, id.y);
    float3 worldPos = centre + id223 * grassSpacing - chunkBoundSize * 0.5f; // no y
    
    float3 textureSamplePoint;
    textureSamplePoint.x = worldPos.x;
    textureSamplePoint.y = worldPos.y;
    textureSamplePoint.z = worldPos.z;
    textureSamplePoint += worldPosOffset;
    textureSamplePoint *= ratio * textureSize;

    grass.enable = colorCmp(requiredColor, universalRenderTex[textureSamplePoint]);

    float groundLevel1, groundLevel2, groundLevel3, groundLevel4;
    float heightMapStep, grassMapStep;
    heightMapStep = 1.0f / float(numPointsPerAxis - 1);
    grassMapStep = 1.0f / float(numGrassesPerAxis);

    int2 heightMapPointTemp = 0.0f;

    // TOPLEFT
    heightMapPointTemp.x = floor(id.x * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    heightMapPointTemp.y = floor(id.y * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    groundLevel1 = GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].twoDimentionalHeight;
    if(!GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].hasMeshAtThisPlace){
        grass.enable = false;
        return;
    }
    // TOPRIGHT
    heightMapPointTemp.x = ceil (id.x * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    heightMapPointTemp.y = floor(id.y * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    groundLevel2 = GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].twoDimentionalHeight;
    if(!GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].hasMeshAtThisPlace){
        grass.enable = false;
        return;
    }
    // BOTTOMLEFT
    heightMapPointTemp.x = floor(id.x * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    heightMapPointTemp.y = ceil (id.y * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    groundLevel3 = GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].twoDimentionalHeight;
    if(!GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].hasMeshAtThisPlace){
        grass.enable = false;
        return;
    }
    // BOTTOMRIGHT
    heightMapPointTemp.x = ceil (id.x * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    heightMapPointTemp.y = ceil (id.y * float(numPointsPerAxis - 1) / float(numGrassesPerAxis));
    groundLevel4 = GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].twoDimentionalHeight;
    if(!GroundLevelDataBuffer[heightMapPointTemp.x + heightMapPointTemp.y * numPointsPerAxis].hasMeshAtThisPlace){
        grass.enable = false;
        return;
    }
    

    float max12 = max(groundLevel1, groundLevel2);
    float max34 = max(groundLevel3, groundLevel4);
    float max1234 = max(max12, max34);

    float min12 = min(groundLevel1, groundLevel2);
    float min34 = min(groundLevel3, groundLevel4);
    float min1234 = min(min12, min34);
    
    // Restrict 'k'
    if(max1234 - min1234 > meshSpacing * 1.2f){
        grass.enable = false;
    }
    

    float testHeight1 = GroundLevelDataBuffer[id.x + id.y * numPointsPerAxis].twoDimentionalHeight;
    float testHeight2 = 0.0f;
    
    float2 interpolation = 0.0f;
    interpolation.x = ((id.x * grassMapStep) % heightMapStep) / heightMapStep;
    interpolation.y = ((id.y * grassMapStep) % heightMapStep) / heightMapStep;
    
    float h1 = lerp(groundLevel1, groundLevel2, interpolation.x);
    float h2 = lerp(groundLevel3, groundLevel4, interpolation.x);
    float height = lerp(h1, h2, interpolation.y);

    float4 pos = 0.0f;
    pos.w = 0.0f;       // Out of order
    pos.x = centre.x - chunkBoundSize * 0.5f + id.x * grassSpacing;
    pos.z = centre.z - chunkBoundSize * 0.5f + id.y * grassSpacing;
    pos.y = height;

    // Offset slightly
    pos.x += lerp(-1.0f, 1.0f, randValue(abs(pos.x) * 45623 + abs(pos.z) * 3461)) * grassSpacing * 0.5f;
    pos.z += lerp(-1.0f, 1.0f, randValue(abs(pos.x) * 73247 + abs(pos.z) * 1237)) * grassSpacing * 0.5f;
    
    grass.position = pos;

    _GrassDataBuffer[id.x + id.y * numGrassesPerAxis] = grass;
}